# -*- coding: utf-8 -*-
"""hw4 dfs&bfs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ykKcV35lMdZx0-rtdVfuw1jm-bgfeqSv

127. Word Ladder
"""

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:

        from queue import Queue
        wd = set(wordList)

        q = Queue()
        visited = set()
        q.put(beginWord)
        visited.add(beginWord)
        step = 0
        while q.qsize() != 0:
            step += 1
            sz = q.qsize()

            for i in range(sz):
                cur = q.get()
                if cur == endWord:
                    return step

                for j in range(len(cur)):
                    for x in range(ord('a'), ord('z')+1):
                        arr = list(cur)
                        arr[j] = chr(x)
                        arr = ''.join(arr)

                        if arr not in visited and arr in wd:
                            q.put(arr)
                            visited.add(arr)

        return 0

"""1197. Minimum Knight Moves"""

def minKnightMoves(x: int, y: int) -> int:
  def neig(cur):
    x, y = cur
    rdir = [-1, -2, -2, -1, 1, 2, 2, 1]
    cdir = [-2, -1, 1, 2, 2, 1, -1, -2]
    res = []
    for r, c in zip(rdir, cdir):
      res.append((x+r, y+c))
    return res

  from queue import Queue
  q = Queue()
  visited = set()
  q.put((0,0))
  visited.add((0,0))
  step = 0
  while q.qsize != 0:
    sz = q.qsize()
    for i in range(sz):
      cur = q.get()
      if cur == (x,y):
        return step
      for each in neig(cur):
        if each not in visited:
          q.put(each)
          visited.add(each)
    step += 1
  return -1

minKnightMoves(5,5)

minKnightMoves(2,1)

"""1644. Lowest Common Ancestor of a Binary Tree II"""

def findlca(root, p, q):
  foundP = False
  foundQ = False

  def find(root, valp, valq):
    if root == None: return None

    left = find(root.left, valp, valq)
    right = find(root.right, valp, valq)

    if left != None and right != None: return root # 后序位置，判断当前节点是不是 LCA 节点
    if root.val == valq or root.val == valp:
      if root.val == valp: foundP = True;
      if root.val == valq: foundQ = True;
      return root

    return left if left != None else right

  res = find(root, p, q)
  if foundP == False or foundQ == False:
    return None
  return res

"""110. Balanced Binary Tree"""

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        def height(root):
            if root is None: return 0

            lh = height(root.left)
            if lh == -1: return -1

            rh = height(root.right)
            if rh == -1: return -1

            if abs(lh-rh) > 1: return -1

            return max(lh, rh)+1

        return height(root) != -1

"""207. Course Schedule"""

class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        def buildGraph(nc, pre):
            graph = [[] for i in range(nc)]

            for each in pre:
                start, end = each[1], each[0]
                graph[start].append(end)

            return graph

        def trav(graph, s, visited, onpath):
            if onpath[s]:
                self.cycle = 1

            if visited[s] or self.cycle:
                return

            visited[s], onpath[s] = 1, 1

            for nexts in graph[s]:
                trav(graph, nexts, visited, onpath)

            onpath[s] = 0


        visited = [0] * numCourses
        onpath = [0] * numCourses
        self.cycle = 0
        graph = buildGraph(numCourses, prerequisites)
        for i in range(numCourses):
            trav(graph, i, visited, onpath)

        return self.cycle == 0

"""79. Word Search"""

class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:

        def dfs(board, i, j, word, k, visited):
            if k == len(word):
                self.found = 1
                return

            if self.found == 1: return

            if i<0 or j<0 or i>=len(board) or j>=len(board[0]):
                return

            if board[i][j] != word[k]: return

            if visited[i][j] == 1: return
            visited[i][j] = 1

            dfs(board, i+1, j, word, k+1, visited)
            dfs(board, i, j+1, word, k+1, visited)
            dfs(board, i-1, j, word, k+1, visited)
            dfs(board, i, j-1, word, k+1, visited)

            visited[i][j] = 0


        self.found = 0
        rows, cols = len(board), len(board[0])
        visited = [[0 for j in range(cols)] for i in range(rows)]
        for i in range(rows):
            for j in range(cols):
                dfs(board, i, j, word, 0, visited)
                if self.found == 1: return True

        return False