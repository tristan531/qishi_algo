# -*- coding: utf-8 -*-
"""hw6 dp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jf5TAYLo55_KbxJWi2B6WtAmPzqhaWVL

70. Climbing Stairs
"""

class Solution {
public:
    int climbStairs(int n) {
        // dp[i]: ways to climb i
        if (n == 1) return 1;
        if (n == 2) return 2;

        int dp[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n+1; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }

        return dp[n];
    }
};

"""486. Predict the Winner"""

class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        // dp[i][j][0 or 1]: [i,j]
        int sz = nums.size();
        vector<vector<vector<int>>> dp(sz, vector<vector<int>>(sz, vector<int>(2, 0)));

        // base
        for (int i = 0; i < sz; i++) {
            dp[i][i][0] = nums[i];
        }

        for (int i = sz-2; i >= 0; i--) {
            for (int j = i+1; j < sz; j++) {
                int left = nums[i] + dp[i+1][j][1];
                int right = nums[j] + dp[i][j-1][1];

                if (left >= right) {
                    dp[i][j][0] = left;
                    dp[i][j][1] = dp[i+1][j][0];
                } else {
                    dp[i][j][0] = right;
                    dp[i][j][1] = dp[i][j-1][0];
                }

            }
        }

        return dp[0][sz-1][0] >= dp[0][sz-1][1];
    }
};

"""62. Unique Paths

"""

class Solution {
public:
    int uniquePaths(int m, int n) {
        // dp[i][j]: num of ways to get i,j
        vector<vector<int>> dp(m, vector<int>(n, 1));

        for (int i=1; i<m; i++) {
            for (int j=1; j<n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
};

"""354. Russian Doll Envelopes"""

class Solution {
public:

    static bool compare(const vector<int>& e1, const vector<int>& e2) {
        if (e1[0] == e2[0]) return e1[1] > e2[1];

        return e1[0] < e2[0];
    }

    int maxEnvelopes(vector<vector<int>>& envelopes) {

        vector<vector<int>> envs = envelopes;
        // sort
        sort(envs.begin(), envs.end(), compare);

        // find lis
        // dp[i] = [:i] lis
        vector<int> dp(envs.size(), 1);
        for (int i=1; i<envs.size(); i++) {
            for (int j=0; j<i; j++) {
                if (envs[i][1] > envs[j][1]) {
                    dp[i] = max(dp[i], dp[j]+1);
                }
            }
        }
        int res = 0;
        for (int i=0; i<dp.size();i ++) {
            res = max(res, dp[i]);
        }
        return res;
    }
};

"""887. Super Egg Drop"""

class Solution {
public:
    int superEggDrop(int k, int n) {
        vector<vector<int>> dp(k+1, vector<int>(n+1, 0));
        // k=0
        // k=1
        for (int i=0; i<n+1; i++) dp[1][i] = i;

        for (int i=2; i<k+1; i++) {
            for (int j=1; j<n+1; j++) {
                dp[i][j] = j;

                int cur = INT_MAX;

                int left=1, right = j;
                while (left <= right) {
                    int k = left + (right-left)/2;

                    int notBroken = dp[i][j-k]; // decreasing
                    int broken = dp[i-1][k-1]; // increasing
                    // int cur = max(dp[i][j-k], dp[i-1][k-1])+1;

                    if (notBroken < broken) {
                        // k too big
                        right = k-1;
                        cur = min(cur, broken+1);
                    } else {
                        left = k+1;
                        cur = min(cur, notBroken+1);
                    }

                    dp[i][j] = min (dp[i][j], cur);
                }

            }
        }

        return dp[k][n];
    }
};

"""115. Distinct Subsequences"""

class Solution {
public:
    int dp(string s, string t, int i, int j, vector<vector<int>>& memo) {
        if (j == t.size()) return 1;
        if (s.size()-i < t.size()-j) return 0;

        if (memo[i][j] != -1) return memo[i][j];

        if (s[i] != t[j]) {
            memo[i][j] = dp(s, t, i+1, j, memo);
        }
        else {
            memo[i][j] = dp(s, t, i+1, j+1, memo) + dp(s, t, i+1, j, memo);
        }

        return memo[i][j];
    }

    int numDistinct(string s, string t) {
        vector<vector<int>> memo(s.size(), vector<int>(t.size(), -1));

        return dp(s, t, 0, 0, memo);
    }
};