# -*- coding: utf-8 -*-
"""hw1 recursion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10QSZi7tqBB365RpR_N2GKvVRWCRqnOU0

21, 231, 203, 698, 794, 761

21.
"""

def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:

        def helper(l1, l2):
            if l1 is None:
                return l2

            if l2 is None:
                return l1

            if l1.val < l2.val:
                l1.next = helper(l1.next, l2)
                return l1
            else:
                l2.next = helper(l1, l2.next)
                return l2

        return helper(list1, list2)

"""231."""

def isPowerOfTwo(self, n: int) -> bool:
        if n == 0: return False
        if n == 1: return True
        return n%2 == 0 and self.isPowerOfTwo(n//2)

"""203."""

def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:

        if head is None: return

        headNext = self.removeElements(head.next, val)
        if head.val == val:
            return headNext
        else:
            head.next = headNext
            return head

"""698."""

def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:

        target = sum(nums)
        if target % k != 0: return False
        target //= k

        sortNums = sorted(nums, reverse=True)

        def bt(nums, bucket, used, kleft, start, target):
            if kleft == 0: return True

            if bucket == target:
                return bt(nums, 0, used, kleft-1, 0, target)

            for i in range(start, len(nums)):
                if used[i] == 1: continue
                if bucket + nums[i] > target: continue

                bucket += nums[i]
                used[i] = 1
                if bt(nums, bucket, used, kleft, i+1, target):
                    return True
                bucket -= nums[i]
                used[i] = 0

                if bucket == 0: return False

            return False

        used = [0] * len(nums)
        return bt(sortNums, 0, used, k, 0, target)

"""794."""

def validTicTacToe(self, board: List[str]) -> bool:
        ctX, ctO = 0, 0
        row, col = len(board), len(board[0])

        for i in range(row):
            for j in range(col):
                if board[i][j] == "X": ctX += 1
                elif board[i][j] == "O": ctO += 1

        if ctX - ctO > 1 or ctX < ctO: return False

        def check(board, p):
            row, col = len(board), len(board[0])
            for i in range(row):
                if board[i][0] == board[i][1] == board[i][2] == p:
                    return True

            for i in range(row):
                if board[0][i] == board[1][i] == board[2][i] == p:
                    return True

            if board[0][0] == board[1][1] == board[2][2]  == p:
                return True

            if board[0][2] == board[1][1] == board[2][0] == p:
                return True

            return False

        checkX = check(board, "X")
        checkO = check(board, "O")

        if checkO:
            if checkX: return False
            return ctX == ctO

        if checkX and ctX != ctO+1: return False

        return True

"""761."""

def makeLargestSpecial(self, s: str) -> str:
        if s == '': return s

        res = []
        ct = 0
        j = 0
        for i in range(len(s)):
            ct += 1 if s[i] == '1' else -1
            if ct == 0:
                res.append('1' + self.makeLargestSpecial(s[j+1:i]) + '0')
                j = i+1
        return ''.join(sorted(res, reverse=True))