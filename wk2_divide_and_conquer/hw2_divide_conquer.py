# -*- coding: utf-8 -*-
"""hw2 divide conquer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11WY9eXxJcwQsIlMQtUqXFM4sa_aa8JK9
"""



"""108. Convert Sorted Array to Binary Search Tree

"""

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:

        # mid point must be root
        if len(nums) == 0: return None

        mid = len(nums)//2
        return TreeNode(nums[mid],
                        self.sortedArrayToBST(nums[:mid]),
                        self.sortedArrayToBST(nums[mid+1:]))

"""169. Majority Element

"""

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        def count(nums, left, right, target):
            ct = 0
            for i in range(left, right+1):
                if nums[i] == target: ct += 1

            return ct

        def helper(nums, left, right):
            if left == right: return nums[left]

            mid = left + (right-left)//2
            leftmajor = helper(nums, left, mid)
            rightmajor = helper(nums, mid+1, right)

            # speed up
            if leftmajor == rightmajor: return leftmajor

            leftct = count(nums, left, mid, leftmajor)
            rightct = count(nums, mid+1, right, rightmajor)

            return leftmajor if leftct > rightct else rightmajor

        return helper(nums, 0, len(nums)-1)

"""240. Search a 2D Matrix II"""

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        def bsearch(matrix, target, row, cs, ce):
            left = cs
            right = ce
            while left <= right:
                mid= left + (right-left)//2
                if matrix[row][mid] == target:
                    return -999 # True
                elif matrix[row][mid] < target:
                    if mid+1 > ce or matrix[row][mid+1] > target:
                        return mid
                    left = mid+1
                else:
                    if mid-1 < cs or matrix[row][mid-1] < target:
                        return mid-1
                    right = mid-1

        def search2D(matrix, rs, re, cs, ce):
            if cs > ce or rs<0 or re>=len(matrix) or rs>re:
                return False

            mid = rs + (re-rs)//2
            split = bsearch(matrix, target, mid, cs, ce)
            if split == -999: return True

            return search2D(matrix, max(mid+1,rs), re, cs, split) or \
                    search2D(matrix, min(mid-1,re), mid-1, split+1, ce)

        return search2D(matrix, 0,len(matrix)-1,0,len(matrix[0])-1)

"""932. Beautiful Array

"""

class Solution:
    def beautifulArray(self, n: int) -> List[int]:

        def helper(nums):
            if len(nums) == 1: return nums

            even = nums[::2] # even indices
            odd = nums[1::2] # odd indices
            return helper(even) + helper(odd)

        nums = [i for i in range(1, n+1)]
        return helper(nums)

"""973. K Closest Points to Origin

"""

class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        getDist = lambda pt: pt[0]**2 + pt[1]**2

        def quickSelect(points, k):
            if len(points) == k: return points

            lbucket, rbucket = [], []
            mid = random.randint(0, len(points)-1)

            for i in range(len(points)):
                if getDist(points[i]) < getDist(points[mid]):
                    lbucket.append(points[i])
                else:
                    rbucket.append(points[i])

            if k < len(lbucket):
                return quickSelect(lbucket, k)
            elif k > len(lbucket):
                return lbucket + quickSelect(rbucket, k-len(lbucket))
            else:
                return lbucket

        return quickSelect(points, k)

"""23. Merge k Sorted Lists

"""

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        def merge(l1, l2):
            if l1 is None:
                return l2

            if l2 is None:
                return l1

            if l1.val < l2.val:
                l1.next = merge(l1.next, l2)
                return l1
            else:
                l2.next = merge(l1, l2.next)
                return l2

        # merge sort
        def mergeSort(lists, start, end):
            if start == end: return lists[start]

            mid = start + (end-start)//2

            left = mergeSort(lists, start, mid)
            right = mergeSort(lists, mid+1, end)

            return merge(left, right)

        if not lists: return None
        return mergeSort(lists, 0, len(lists)-1)