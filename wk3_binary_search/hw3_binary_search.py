# -*- coding: utf-8 -*-
"""hw3 binary search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OkVNYFz1wXrVI2IW8efEMc3TFclTdhaH

167. Two Sum II - Input Array Is Sorted
"""

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers)-1

        while left < right:
            curSum = numbers[left] + numbers[right]
            if curSum > target:
                right -= 1
            elif curSum < target:
                left += 1
            else:
                return [left+1, right+1]

"""278. First Bad Version"""

# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:

        left, right = 1, n

        while left <= right:
            mid = left + (right-left)//2
            if isBadVersion(mid):
                right = mid-1
            else:
                left = mid+1


        return left

"""702. Search in a Sorted Array of Unknown Size"""

class Solution:
    def search(self, reader, target):
        left, right = 0, 20000
        while left <= right:
            mid = left + (right-left)//2
            if reader.get(mid) >= target:
                right = mid-1
            else:
                left = mid+1
        return left if reader.get(left) == target else -1

"""852. Peak Index in a Mountain Array"""

class Solution:
    def peakIndexInMountainArray(self, arr: List[int]) -> int:
        left, right = 0, len(arr)-1

        while left <= right:
            mid = left + (right-left)//2
            if arr[mid] > arr[mid+1] and arr[mid] > arr[mid-1]:
                return mid
            elif arr[mid] > arr[mid+1]:
                # left side
                right = mid-1
            else:
                # righht
                left = mid+1

"""1201. Ugly Number III

"""

class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        def gcd(a, b):
            # euclidean algo
            if a < b: return gcd(b, a)
            if b == 0: return a
            return gcd(b, a % b)

        def lcm(a, b):
            return a*b / gcd(a, b)

        def f(num, a, b, c):
            # return: in [1:num] inclusive, how many ugly
            seta = num // a
            setb = num // b
            setc = num // c
            setab = num // lcm(a, b)
            setbc = num // lcm(b, c)
            setac = num // lcm(a, c)
            setabc = num // lcm(lcm(a, b), c)

            return seta + setb + setc - setab - setac - setbc + setabc

        # goal: find the smallest num s.t. f == n
        left, right = 1, 2 * 10 ** 9

        while left <= right:
            mid = left + (right-left)//2

            ct = f(mid, a,b,c)
            if ct < n:
                left = mid+1
            elif ct > n:
                right = mid-1
            else:
                # find left bondary
                right = mid-1
        return left